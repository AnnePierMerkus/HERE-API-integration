<!DOCTYPE html>
<html>

<head>
    <title>HERE Maps API Route Display</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
    <script type="text/javascript">
        var platform = new H.service.Platform({
            apikey: '5IL-qoY4WWXxh_SR8nilsXjHQSDx910CYiaUS-CcH2k'
        });
        var map;

        function fetchRouteData() {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest();
                var url = 'https://router.hereapi.com/v8/routes?destination=52.089444,5.110278&origin=52.365760,4.920020&transportMode=scooter&vehicle[speedCap]=14&return=polyline&apikey=5IL-qoY4WWXxh_SR8nilsXjHQSDx910CYiaUS-CcH2k';

                xhr.open('GET', url, true);
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        var response = JSON.parse(xhr.responseText);
                        var polylineString = response.routes[0].sections[0].polyline;

                        resolve(response);  // Resolve with the full response
                    } else {
                        reject('Error fetching route data: ' + xhr.status);  // Reject with error message
                    }
                };
                xhr.send();
            });
        }


        async function initMap() {
            var respnose = "";
            var polylineString = "";
            try {
                // Wait for the route data to be fetched
                response = await fetchRouteData();

                console.log('Full Response:', response);

                // Extract polyline if needed
                polylineString = response.routes[0].sections[0].polyline;
                const decodedPolyline = decode(polylineString);

                console.log('Decoded Polyline:', decodedPolyline);

                // Now you can proceed to initialize your map using the full response and decoded polyline
                // Map initialization code goes here, using response and decodedPolyline

            } catch (error) {
                console.error('Failed to fetch route data:', error);
            }
            
            fetchRouteData();
            var defaultLayers = platform.createDefaultLayers();
            map = new H.Map(document.getElementById('map'), defaultLayers.vector.normal.map, {
                center: { lat: 52.96092, lng: 5.92378 }, // Center map on departure
                zoom: 12
            });

            // Using the response you provided
            var routeResponse = {
                "routes": [{
                    "id": "0ca0d494-6ed1-4e20-84d5-d136c74a904b",
                    "sections": [{
                        "id": "fc098ae9-851d-4982-a560-bee076b5edf1",
                        "type": "vehicle",
                        "departure": {
                            "time": "2025-01-02T16:41:30+01:00",
                            "place": {
                                "type": "place",
                                "location": { "lat": 52.365760, "lng": 4.920020 }
                            }
                        },
                        "arrival": {
                            "time": "2025-01-02T18:15:32+01:00",
                            "place": {
                                "type": "place",
                                "location": { "lat": 52.089444, "lng": 5.110278 }
                            }
                        },
                        "transport": { "mode": "vehicle" },
                        "polyline": "BGq4k8jDwppsJ-IrXMfuD3JKb8G_TgK_d8Q3wBsOvqBsEvMgFrOwMriBkD_J8GrT8Vj_BoGjNkDrEkDrEoBjDUrEoB_O8LgK7L_JgPztBzKnL3IvH3cnanL_J3mBnkBnGzFzUjSnGnG3IvH7QzP3NvMvCvCzF_ErE7B_EA7BA7G8B7awMzFwCrJsEjDUnBTze_JnL3D7QzF_EwC_E8BrEwCjD8B_E4D3hB4S3XkNzF7arErTnGrdnBnGrE3S7BjInG_d3I7uB3DrT_ErJ_OsJ_JoGnG4DjIgFvHsE3DwCjD8B7G4D3I0F7QgKzZgP3XsO_Y0P3hBgUvHsE3D8BzF4D3DwCnQsJzFkD_d8QriBsT7uBsdrJoGvlB8VrToLrOkInLoGriBoVzeoVzPsJvMkI_JoGrOkIrO4I7G4DnGsE_EkDrEsE3DsEzF4I_EkInGoLrTkhB_EsJ3S4hBnGoL_JoQrE4I_EkI_E4IzFsJjDsEjDsE3DoGvHgK_E8G_E8GzFwHnG8LrE8G_E8GnGkIjIgKnGwHvHkI_JsJ_EsEnLkI7GoG3DgFjD8GnBoGT0KoB0K4D8Q8GgtBkD8VgFgjBkIo4BwCwW8BoQoB8VAgPjDgezF0ZnGkXnGgPjN4XzK8Q7GgK_JsOnakmBnL8Q7BkDrO8VzKgPjIwMzKgPnG4IvlBg3BniCkiDvhD4vErgC0_C3rBk_BvWkhB7Vof7kB8zB3IoL3NkSnL0Pna0jBnfwvBnQ8ajD0FrEsJ_JsTzZ0yBzP0e7LwW_EsJzFoLrE8GjD0F7G8LvCsE7BkDvMsTnB8BvMgZzFsJzK8Q3DoG_O0Zna0oBjNwWnQ8azZssBrEwH3I0PnLsTzKkS3N4XvMsTnL0P7L0PrO0PvMkNvWoVjSoQ7VoVrT4SjuC8nCvRgP3N8L7Q0PjN8LvlBkhBzjB4hBzesdjNwMnzB0tB7uB4mBjDwC_Y0U3wBkrBrYkXvMoL_EgF3wBssBvWgUjkC89B7L0KvH8GzFgFvlB4hB7sC0mCriB8f3IkIzFsE3D4DzKgK3XoVnpBkmBzKgK7VgUjIwH3DkDjDkDzFgFnG0FvH8GjN8LnpBwlB_EsE_EsErYwWr2BsxBvlBgjB3kC4_BnGoGnuBopBjwBwqBrJsJzKsJzF0F3DkD3DkDvH0F3NoL7VoVzFgFzPgP_J4IzF4D_E4DjI4DvCnBvCT3DT3DU7GwCzFkDrE4DjD4DjDgF7BoGnBsE3DwH3D8G3DwHrE0F_JgK_OkN7GwHzF8GzFkI_E4IrEsJjDsJ7BkI3I4hBvC8L7BsJ7BkITwHjDkI3DkIjDoGjDgF3DgFrEgFzF0F7GoG3D4D3DkDjDkDvC8BvMoLrTkSzKsJvR0PnfsdzewbnG0FjN4N_J8LvHgKrJkN7GoLzFoL_EoLnG0PrEgK3DwHjD0FjDsE_ETrE8B3D8BrEAzFnBnGvCnGjD_E3DzFzFT3DnBjDnB7BnBnB7BnB7BA7BU7BoBnB8BnBwCzU_JrOvHnG3DvC7BnG_E7G7GrET_EjI_E_JnBjDjD7GnBjDjDjIzFzPzKze7G_TnLriBvHvW3DzKrTv5BnBjD7BzF7BrEnB3DzF7Q3DnLnBjI_EzPnG3SoBjDU3DAjDT3DnBjDnB7B7B7BnBT7BA7BU7BoB7B8BnBwCT8BTkDAkDnkBoQjSkIrT4IvH4D3DsEzFwCzKgF7LgFzFwC3DnB_E8BjI4DjDoBjN0FzKsEjI4D_E0FvH4DzFwC_EwCjI4DjS8G7GkDnG8BnGoBnGU7LArEA3DA3NA7LArJA_EvCnGA3IA3IU7LUTvCnBvCnB7BnBnB7BTvCAvHvgBjDjNvCrJvC_EvCzKnG7arEjS7G_d7BjI7BjITjD3D7QnGvbnBnGnBzF7B7GvH3hB3IjmBnGjc_EvWrErTvCzKUzF7BrJTvCvCnLjDzKvC3I_E3N7BrE3DjIvC_EvC_EjD7GvCnGjDjIjDjIrErOvCvH7B3I7BvHvCrJ7BnGjDrJ_ErOnLnfjI3X3IrYjI_YvC3I3D_E3IzZnBjDrE3NzF7QvHnV3DzK3D_JnBrJjD3InBvCvCvHnG3SrEsEzZ4Nv-BwlB3XsOnf8Q7G0FvC8BrTsJnpBkXvjCgoB_xB4hB7GsEnLkIvCkDrnB0jB7xCk_B7BoBnV4N7GwCjmB8G3NoL_OsdzPkmB3NwgBvMoa7LwRnLoLnG0FnLwHjI0F7GsEjI4Dr3DwyC39Co9BjDrE3D7B7BA_ErOnLnfvC7G3DjI_JTnG4D_E4DjD4DjDoGnLgoB7B8G7Lge_d4mB3IkN3DsE7GoG_E4IzFgPzFkInQwRT4NnBwHnBkDvCkD3DoBvH8BjIoBrJT_O3DzFT7L_E_O_EnG3DvRrJjI_EvH_EjD7BvC8G7BgF7BoG7B4I_EkcvC4N7BgKvC0KvC0KjDwMvC8L_Eoa7BwHnGsYvC0K7BsJnBwH7BsJvC0KvCsJ7BoGjDoLjDwMjDoLvC4IjD8L3DkN3D8LzFoQjD4IjDkIvCoGjD8G3D4I_E8LrEgK3IgU_EgKnG8LrEwHnGsJ_EoGvHwHvH8GnGgFjIoGnGsE_O0KrsBof_xBgjBjvE0kDvwDsvCrY8Qna4SnkB0Z_J8G_d8VrE4DjDwC7B8B3D4DjD4DvCkDvC4DjD0FnGkN_O0e3I8QrE4I3DwH3DoG3DgFrEsE_EsEnGgF_E4D_E4DnG0FzF0FzF8G_EoG3D0F3DoG3DwHjD4IvCgKjDgPnBwH7BsJ7BwHvCoGjD0FzFoGvCwC_EsErEkDnG4D7G4DzFwCvHkDvMsEzKsEnLsErJsE_iB8QzFwC7GkDnV0KrO8GjNoG_TgKvlBsTvM0FrJ4DrJ4DnLkD7LwCnL8B3N8B7QoB_OAjIoB7GoBvH8BzFoB_EoBzFU3InB3DnB3DvCvCnBvH_ErJnG3DjDvCvCjDvC_E_EnGnGzFnGjD3DrdvgB7GjIjS_T3I_JjhB7kBjD3D7B7B3D3D3DrEzK7LjX_Y7LjN_ErErEjDrE7BrET3DoBrE8BvC8BjDkDjDsE3D0F3D8GvH8LjDsEnB8BjD4DnGoGzFgF7G0F_JwHjIoGrJ8GjIgFvH4DrJsE7GkD3D8B3D8B7BoBzF4DzFsEnGoG7G8GnGoGnVkXnsCs0CrJoL3I8L7GgKvH8LvHwM3IgP_E4IjD0FjIoQ7GgPzFsO_EgP_EoQ_EkS3D0P3DwRjDoQnBgFjD4SjD8VjDsY_E8pB7BgP7BoL7BoLvC0KjDwM3DwMjD4I3DgKjDkIvHgUvCoG_E8LrEsJ_EgKzF0KzFsJ7GgK7GkInG0FvHoGvHgF7G4D3IkDrJoB_ETjDT7GvC3IrEjIrE3I_EnGrEzFrEnGzFvHvH3D3D7GjIzFvHnGrJzFrJjIvMjD_EzFrJvCrE3DvHvC_E3DjI3D3IrE7L3DnLrEjNrEnQ_E7VzF7a7GnkBnG_iB7GrnB7BnLvCnLvC3SnB_JvCrT3DzZjD7V_EvlB7B3N7BrOvCjSvC_OvC7LvCzK3DvMrEjNvHrTzFjNzF7LrEvH_E7G_E_EzF3DzFvCzFnB7GT7GoB7GkD_EkDzFsEnG0FvHkI7GwHvH4IzFwH_EwHrE8GrEwH3DoGnBwCnG0KjNwW3I0PnL0UnLoVjN4X3IoQvHsOnGkN7G4NjNgZzF0KzFsJrE8G_E8G7GkInGwHvCwCrO0PrEsEjDkDvCwCrE4DjDwCvC8B3I0FzFkD_EwCzFwCvHkDrJkD7G8BvHoBvHUvHA7BArOTvCAvHnB7GT7GnB7G7BjIjDnGvC7GvCnG7BnBAzFnBvHT7GU7G8B3IkDvHkD7G4DzF4DzFsEzFsE7GoGrJ4IvC8BjDwCzFkDvHwCnG8BA4NnBwRnB4IvCgZ3DwlB3D8kBjDouBnB0PAwMvHgrC7L4xDjD8anBgK3DgoB3DsnBnBgK7GkpC3DkcvC0P7G8f3IsiBvC4I3DwHjDgKjD0KrE0P7B8GjDsOvCsEnBsE7BwM7BkNvC0KjD4I_EoGjD4D_EsErEwCjIsEnGTvHTnL7BzP3D3NrEjIvCnBTvM_E3NnGjD7B3D7BzFvCvgBnQ_TzK3mBzUnLzFjmB_TrnBzUzoBzU_T3I7Q7GrJvCzK7B7GTrJAjIoB_TsE7L4DnL0FzK8GnawWzU0UrO8QrJkNjIgPvH0P_J0ZnGsT_JkhB3XkzCrOwvBjD4IjDsEvHwHvCzF3DjD_EA3D4DvCsJT0FjN0F_O0F_OwC_JA3I3D7GrErOrJzKnL7LvR3IrT_E_OrE7VvCjSjDnVjD_iBrE_YrJ7anGjNrJnQ3I_J7L_JzFjDjIjD_O7BnLTjIUjIkDvH4D_TgPvW4S7LgKnBoBvHgFnG4D7BoBrJkIzUoQjmB4c3I8GvM0KjI4IvHgKnGoLnGsO_EkN_E0UrJssB3D8QjDkN3DwR3DoQrE0K_EwHvHgK3DwHvC4IvCwR7B4I7BwHjD4IjD8GjDoGvCsEjDgF3DsEjDkD3DkDrEkDrEwCrE8B3DoBrEoBrEU_EAjNAjIT3ITvgBnBvWU3IoBnGoBjIkDzKoGvHkDnG8B7GoBzPAzPnBvMnBvM3D7L_EjIjD7BTzKrEnGjDrE7BnQrJ3IvHjI3IvM_OrO7Q7Q_T7L7Q7L_TzFzPjDjNrE3SnGzZnGzUrEnLrEnL7GzPrJvRzKjSrJ7QzK_OnVvbnVnazUzZ_JvM_E7GzF_JzFjN_EnQjD_OvCjST7GT_JAztBA3NT3InBnL7B7LvCvMvCzK7GjXrE_OjD3IjDvHvCnG_J7V_EnL3I_T7G7QzFrOnG_O7G7Q_E7L3DrJjDvHrEzKvCnGrErJrEjIjDzF3D7G_EvHrEnG3D_E_E7G3D_EzFzFzF_EzF_E_JvHvHzFvH_EvHrEnL7GvHrEjSrJ3NnGjI3D3IjD3NrEnG7BvH7BzFnB3N7B3IT_TArJUjIoB7G8BvHwC7GkDnGwC7G4DrJoGnG0F7GoGzFoGrEgFzP4SvHgK_EoGnGkIzF8GvH4IrJ0KnGoGzFgFnGsE_E4DrJgF_JgFnL4DvRgFvW8G36B8QnL4DvW8GjI8B7LoBnQAzPnBrT7B7GnBnG7BrJ3DjNjD_JnBrJUjIAvHnBrTrEnQrE3IvCvHnBjITvHjDzK3D3X7G7QrE_JjDrJrEzF7B7GTnGTjI7BnQzF7QjIvbnQ3NrJzF3DzFrEzFzFjDjDrE3DrJjDzFnB7G3DnGrErEvCjS7LrEjD7LvHnL7GzKnGvMnGjX_JrEnBrJjD3I7B3DT_ET_JnBrJT_TTzUTzKT3I7B7L7B_J7B7GnBnLnBnBAvH7BvHvCzFjDzUzK7G3DjD7BjD7BzF7B_E7BjXvH_TzF3S_EjIvC_YvHvH7B3IvCjInBnGUjIkD7GkDvHgF7BoBnBU3I0F7LoG3DwCjDwCjNwMnL0KzKkI7G0F3IwH7QsOvMwM7GwH_E8GvCkDvHgK3DoGvHoLzKoQzFwH_EsErE8BjDUTvCnBvCnB7BnBnB7BT7BA7BUnBoBnBoBnBwCT8BT4DAwCUkDU8BoBwCoB8BoBoBrEkS3NwWnagoB7fkwB7B7BrE7BrE8B7BwCnBwCnB8GoB8GoBwCrJgP3SsdnzBgwCvHoLnG4I3IoLnGoGnGsEzK4Dn4BsOzewH3ckI3SgFzP0F3coLvlBgPnLsEnBU3N8G7L8GnfoV_OoL_JkIzKgK_O8QrO4SzP0UrO0U3I0PvH8QrJkXzPsnB_E8Q_EwWjDsT3D8V7GwgBrEsTnGoV3IsYvHwRnG4N3D8G7B4DjDgF3IwMrEoGnLoQrOkX3N4SvMsO7L8L7LgKvHgF_JoGvHkD7L4D7L8BjIAvHAnLnB3SnBvMoB3IwCjIkD3IgF_JoGrJ4I_JoLrJkNrJ0P3DwHjDwH3DgKjD4IrE8Q3D0P_EwbzF4cjI4hB_JkhB_Tk_BvMwlBzFgU_E0UjI8kBrEwW7B8LjNs5C3Ig3B3D8Q_EkSzF8QvHkSrJwRrEwHjDsE3IoLrO0PrO8LzK8GrOwHjN0FnLsEvHkDrJwC3SoG_J8BrJoBrJU_JTrJnB_J3D_JzF3I3D3I_E7QzK3XvRjN3I3S7L_dzPjN3DrYjInL3DrTvCvW3DrJnBrJnB3IoBnV0F3XgKjXkN7pBgerTwM_T4N3N0KvHkI7GoGvHwHjD4D_JkNzFwHrEoG7G0K3I4NnVsiBjc0tBzPoazK0PnL0PnBnBnBnB7BT7BAnBUnBU7BwCTwCTkDAkDUkDU8BoB8BrEkIvH8L3N0UjhBk1BjDsEnG4IjD4DnB7B7B7B7BT7BA7BUnBoBnBoBnBkDTkDA4DUkDoBkDoB8B3DwHnG4NrJ8Q_JkN7BwCzFwHvHkI3IgK7GkI7GwH3IgKnpB4rBrJsJzKkIzFwCTvCnBvCnB7B7BnBvCT7BU7BU7B8BnBwCnBkDTkDAkDUkDUwCoBwCoB8B8B8BvCwMvC8LrEsO3IwW3S0oB3Noa_EgK3DkI_JwW3I0UvHoQrE8GnL4SnVkhBzFsJ3D0FrEkInBkDnB4D7BT7BAnBUnBoBnBkDTkDA4D_E4DzKkNvH0K_E0FrO0PvgBkhBnV4XrYkhBrE0F_YgjBnL0P_OoVvvB0hCnQwWnLkS_iBg8BjwBs0C3I0PjmB0hCrJoQriBs7BrOsYnQwbjI4N7LgUrJoQ_T4hBrjD8rFnLsTjD0Fr2Bg_C7V8kB7awvBrOsYjNwWvC4DnLgU_iB89B3N4XrEwHrE8G3XopBvCsEvC4D_JwRjS8f7L0UjckwBvgB84BrY8pB3cgyB3IgPnkBw-BvWsnBnG0K7GoLnLgUnLsT3mBkkCvgBg3BjSofnQ4crsBwtCrY8pBrTkhBvM8VvWsnBjI4N7Qwb7a8uBrEkIjmB0hCvb8uB3IsO7GwM7VwlBnBwCjDgF3c0yBrY8pBvW4mBrxBo2CnV8kBzew0B_O0Z7L8V7G8LrJoQ7BkDvCsE_O0Z7VkmB_E4IrnBkkC7QsdrOsY_J8Q_E4IrJ8QjDgFrTkhBjSofvCsEjDgFrYwqBjIgPrJ8Q3Sof7G8L_T4hBzKsTjI4N_OoazP8ajDgF7LgUnGoLnLsTnG0K3I0P7GoL_EkIrJwRvbwvBrEwHjD0FjN8V3D8GzKkSjI4NjI4N_EkI_EsJvCsEjD0FjI4NjIkNvHkN7B4D3NsY7B4DrJ0P7G8L_JwRvRsiBrEsJ3DsEvC4DrJgPnGkI3DsEjDkDrEgFjDkDjDkD3DkDvCwCjDwC3IkIvM0K_EsEnG0FrEgFrEsEnG0F3D4D3DkD_EsE3D4DzFsEzFgF3IwH7LgKrE4D_EsE_EsE_EsE3D4DrEsE_EgFzF0FrJsJ3DkDvCwCrE4D7GoGrJ4I3N8L_EsE_EsEzFgFjIwH3NkN7B8B_JsJrYsYvM8L7LoL3IwHnG0F7LoLnG0FvHwH_EsEvH8G3IkIrJ4I_EgFjDkD7B8B_EoGrEoGrEzK7GzU3IzZ3DzKvCvHrE_OT_J8BrE4mB7kB"
                    }]
                }]
            };



            // Extracting the departure and arrival coordinates
            var departureLatLng = response.routes[0].sections[0].departure.place.location; // routeResponse.routes[0].sections[0].departure.place.location;
            var arrivalLatLng = response.routes[0].sections[0].arrival.place.location; //routeResponse.routes[0].sections[0].arrival.place.location;
            // const polylineString = routeResponse.routes[0].sections[0].polyline;

            // Add the departure and arrival points as markers on the map
            var departureMarker = new H.map.Marker(departureLatLng);
            var arrivalMarker = new H.map.Marker(arrivalLatLng);
            map.addObject(departureMarker);
            map.addObject(arrivalMarker);

            // Optionally, add a line between departure and arrival points
            var lineString = new H.geo.LineString();
            lineString.pushLatLngAlt(departureLatLng.lat, departureLatLng.lng);
            var decodedPolyline = decode(polylineString);
            decodedPolyline.polyline.forEach(point => {
                lineString.pushLatLngAlt(point[0], point[1]);
            })
            lineString.pushLatLngAlt(arrivalLatLng.lat, arrivalLatLng.lng);

            var polyline = new H.map.Polyline(lineString, {
                style: { strokeColor: 'blue', lineWidth: 5 }
            });
            map.addObject(polyline);

            // Adjust the map's viewport to fit the route
            map.getViewModel().setLookAtData({
                bounds: polyline.getBoundingBox()
            });
        }


        /*
 * Copyright (C) 2019 HERE Europe B.V.
 * Licensed under MIT, see full license in LICENSE
 * SPDX-License-Identifier: MIT
 * License-Filename: LICENSE
 */
        const DEFAULT_PRECISION = 5;

        const ENCODING_TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

        const DECODING_TABLE = [
            62, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
            22, 23, 24, 25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
            36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        ];

        const FORMAT_VERSION = 1;

        const ABSENT = 0;
        const LEVEL = 1;
        const ALTITUDE = 2;
        const ELEVATION = 3;
        // Reserved values 4 and 5 should not be selectable
        const CUSTOM1 = 6;
        const CUSTOM2 = 7;

        const Num = typeof BigInt !== "undefined" ? BigInt : Number;

        function decode(encoded) {
            const decoder = decodeUnsignedValues(encoded);
            const header = decodeHeader(decoder[0], decoder[1]);

            const factorDegree = 10 ** header.precision;
            const factorZ = 10 ** header.thirdDimPrecision;
            const { thirdDim } = header;

            let lastLat = 0;
            let lastLng = 0;
            let lastZ = 0;
            const res = [];

            let i = 2;
            for (; i < decoder.length;) {
                const deltaLat = toSigned(decoder[i]);
                const deltaLng = toSigned(decoder[i + 1]);
                lastLat += deltaLat;
                lastLng += deltaLng;

                if (thirdDim) {
                    const deltaZ = toSigned(decoder[i + 2]);
                    lastZ += deltaZ;
                    res.push([lastLat / factorDegree, lastLng / factorDegree, lastZ / factorZ]);
                    i += 3;
                } else {
                    res.push([lastLat / factorDegree, lastLng / factorDegree]);
                    i += 2;
                }
            }

            if (i !== decoder.length) {
                throw new Error('Invalid encoding. Premature ending reached');
            }

            return {
                ...header,
                polyline: res,
            };
        }

        function decodeChar(char) {
            const charCode = char.charCodeAt(0);
            return DECODING_TABLE[charCode - 45];
        }

        function decodeUnsignedValues(encoded) {
            let result = Num(0);
            let shift = Num(0);
            const resList = [];

            encoded.split('').forEach((char) => {
                const value = Num(decodeChar(char));
                result |= (value & Num(0x1F)) << shift;
                if ((value & Num(0x20)) === Num(0)) {
                    resList.push(result);
                    result = Num(0);
                    shift = Num(0);
                } else {
                    shift += Num(5);
                }
            });

            if (shift > 0) {
                throw new Error('Invalid encoding');
            }

            return resList;
        }

        function decodeHeader(version, encodedHeader) {
            if (+version.toString() !== FORMAT_VERSION) {
                throw new Error('Invalid format version');
            }
            const headerNumber = +encodedHeader.toString();
            const precision = headerNumber & 15;
            const thirdDim = (headerNumber >> 4) & 7;
            const thirdDimPrecision = (headerNumber >> 7) & 15;
            return { precision, thirdDim, thirdDimPrecision };
        }

        function toSigned(val) {
            // Decode the sign from an unsigned value
            let res = val;
            if (res & Num(1)) {
                res = ~res;
            }
            res >>= Num(1);
            return +res.toString();
        }

        function encode({ precision = DEFAULT_PRECISION, thirdDim = ABSENT, thirdDimPrecision = 0, polyline }) {
            // Encode a sequence of lat,lng or lat,lng(,{third_dim}). Note that values should be of type BigNumber
            //   `precision`: how many decimal digits of precision to store the latitude and longitude.
            //   `third_dim`: type of the third dimension if present in the input.
            //   `third_dim_precision`: how many decimal digits of precision to store the third dimension.

            const multiplierDegree = 10 ** precision;
            const multiplierZ = 10 ** thirdDimPrecision;
            const encodedHeaderList = encodeHeader(precision, thirdDim, thirdDimPrecision);
            const encodedCoords = [];

            let lastLat = Num(0);
            let lastLng = Num(0);
            let lastZ = Num(0);
            polyline.forEach((location) => {
                const lat = Num(Math.round(location[0] * multiplierDegree));
                encodedCoords.push(encodeScaledValue(lat - lastLat));
                lastLat = lat;

                const lng = Num(Math.round(location[1] * multiplierDegree));
                encodedCoords.push(encodeScaledValue(lng - lastLng));
                lastLng = lng;

                if (thirdDim) {
                    const z = Num(Math.round(location[2] * multiplierZ));
                    encodedCoords.push(encodeScaledValue(z - lastZ));
                    lastZ = z;
                }
            });

            return [...encodedHeaderList, ...encodedCoords].join('');
        }

        function encodeHeader(precision, thirdDim, thirdDimPrecision) {
            // Encode the `precision`, `third_dim` and `third_dim_precision` into one encoded char
            if (precision < 0 || precision > 15) {
                throw new Error('precision out of range. Should be between 0 and 15');
            }
            if (thirdDimPrecision < 0 || thirdDimPrecision > 15) {
                throw new Error('thirdDimPrecision out of range. Should be between 0 and 15');
            }
            if (thirdDim < 0 || thirdDim > 7 || thirdDim === 4 || thirdDim === 5) {
                throw new Error('thirdDim should be between 0, 1, 2, 3, 6 or 7');
            }

            const res = (thirdDimPrecision << 7) | (thirdDim << 4) | precision;
            return encodeUnsignedNumber(FORMAT_VERSION) + encodeUnsignedNumber(res);
        }

        function encodeUnsignedNumber(val) {
            // Uses variable integer encoding to encode an unsigned integer. Returns the encoded string.
            let res = '';
            let numVal = Num(val);
            while (numVal > 0x1F) {
                const pos = (numVal & Num(0x1F)) | Num(0x20);
                res += ENCODING_TABLE[pos];
                numVal >>= Num(5);
            }
            return res + ENCODING_TABLE[numVal];
        }

        function encodeScaledValue(value) {
            // Transform a integer `value` into a variable length sequence of characters.
            //   `appender` is a callable where the produced chars will land to
            let numVal = Num(value);
            const negative = numVal < 0;
            numVal <<= Num(1);
            if (negative) {
                numVal = ~numVal;
            }

            return encodeUnsignedNumber(numVal);
        }

        window.onload = initMap;
    </script>
</head>

<body>
    <div id="map" style="width: 100%; height: 500px;"></div>
</body>

</html>